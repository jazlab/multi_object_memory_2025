"""Compute selectivity of units to position and identity.

This script computes the p-values and AUCs for the selectivity of each unit's
delay phase firing rates to position and identity. The results are saved to CSV
files in the cache directory `../../cache/phys_processing/selectivity`.

Usage:
$ python3 run_cache_selectivity.py

This script requires the following cached data:
- Firing rates for each unit in the delay phase, saved in
  `../../cache/phys_processing/spikes_to_trials/delay_phase_firing_rates`. This
  can be generated by running the script
  `../spikes_to_trials/run_delay_phase_firing_rates.py`.
- Behavior data for the triangle and ring tasks, saved in
  `../../cache/behavior/triangle.csv` and `../../cache/behavior/ring.csv`. This
  can be generated by running the script
  `../../behavior_processing/run_cache_data.py`.
"""

from pathlib import Path

import auc as auc_lib
import numpy as np
import pandas as pd

_CACHE_PATH = Path("../../cache")
_FIRING_RATES_DATA_DIR = (
    _CACHE_PATH / "phys_processing/spikes_to_trials/delay_phase_firing_rates"
)
_WRITE_DIR = _CACHE_PATH / "phys_processing/selectivity"
_BEHAVIOR_CACHE_PATH_TRIANGLE = _CACHE_PATH / "behavior/triangle.csv"
_BEHAVIOR_CACHE_PATH_RING = _CACHE_PATH / "behavior/ring.csv"

# Filter parameters
_MIN_FIRING_RATE = 1.0  # Minimum mean firing rate to consider a unit
_MAX_P_VALUE = 0.05  # Maximum p-value to consider a unit significant
_MIN_AUC = 0.65  # Minimum AUC to consider a unit significant
_N_BOOTSTRAP = 5000  # Number of bootstrap samples for p-value computation


def _theta_to_location(theta):
    """Convert theta to location."""
    theta = theta + np.pi / 3
    theta = theta % (2 * np.pi)
    location = int(np.floor(3 * theta / (2 * np.pi)))
    location = min(2, location)
    return location


def _trial_to_object_locations_triangle(trial, num_objects):
    """Get object locations for triangle task trial."""
    if not trial.on_triangle.values[0]:
        return None
    obj_locations = [
        int(trial[f"object_{i}_location"].values[0])
        for i in range(num_objects)
    ]
    return obj_locations


def _trial_to_object_locations_ring(trial, num_objects):
    """Get object locations for ring task trial."""
    # Get object thetas
    obj_thetas = [
        trial[f"object_{i}_theta"].values[0] for i in range(num_objects)
    ]

    # Reject if this is a 2-object left/right trial, because those are
    # over-represented in the data
    if (
        num_objects == 2
        and np.isclose(obj_thetas[0], 0)
        and np.isclose(obj_thetas[1], np.pi)
    ):
        return

    # Convert thetas to locations
    obj_locations = [_theta_to_location(x) for x in obj_thetas]

    # Reject if this is a 2-object trial and both objects are in the same
    # location
    if num_objects == 2 and obj_locations[0] == obj_locations[1]:
        return

    return obj_locations


def _get_selectivity(df_unit_firing_rates, session_behavior):
    """Get selectivity."""

    # Get mean firing rate for each trial per phase
    firing_rates_per_trial = []
    object_locations_per_trial = []
    object_identities_per_trial = []
    for _, row in df_unit_firing_rates.iterrows():
        trial = session_behavior.loc[
            session_behavior["trial_num"] == row.trial
        ]
        num_objects = trial["num_objects"].values[0]

        # Get object locations and identities
        if row.task == "triangle":
            obj_locations = _trial_to_object_locations_triangle(
                trial, num_objects
            )
        elif row.task == "ring":
            obj_locations = _trial_to_object_locations_ring(trial, num_objects)
        if obj_locations is None:
            continue
        obj_identities = [
            trial[f"object_{i}_id"].values[0] for i in range(num_objects)
        ]

        # Get start and end indices for firing rates
        firing_rates_per_trial.append(row[f"firing_rate"])
        object_locations_per_trial.append(obj_locations)
        object_identities_per_trial.append(obj_identities)

    # Compute conditions
    positions_per_trial = [
        tuple(sorted(x)) for x in object_locations_per_trial
    ]
    positions_per_trial_unique = sorted(list(set(positions_per_trial)))
    identity_per_trial = [
        tuple(sorted(x)) for x in object_identities_per_trial
    ]
    identity_per_trial_unique = sorted(list(set(identity_per_trial)))
    if df_unit_firing_rates.task.values[0] == "triangle":
        if len(positions_per_trial_unique) != 7:
            raise ValueError("Not all positions present")
        if len(identity_per_trial_unique) != 7:
            raise ValueError("Not all identities present")
    elif df_unit_firing_rates.task.values[0] == "ring":
        if len(positions_per_trial_unique) != 6:
            raise ValueError("Not all positions present")
        if len(identity_per_trial_unique) != 6:
            raise ValueError("Not all identities present")

    # Compute selectivity for position and identity
    auc_conditions = {
        "Position": [((0,), (1,)), ((0,), (2,)), ((1,), (2,))],
        "Identity": [(("a",), ("b",)), (("a",), ("c",)), (("b",), ("c",))],
    }
    return_stats = {}
    for modality, pairs in auc_conditions.items():
        if modality == "Position":
            conds_per_trial = positions_per_trial
        elif modality == "Identity":
            conds_per_trial = identity_per_trial

        p_values = []
        auc_values = []
        for pair in pairs:
            firing_rates = [
                [
                    fr
                    for x, fr in zip(conds_per_trial, firing_rates_per_trial)
                    if x == condition
                ]
                for condition in pair
            ]
            p, auc = auc_lib.compute_statistics(
                firing_rates, n_bootstrap=_N_BOOTSTRAP
            )
            p_values.append(p)
            auc_values.append(auc)
        p_values = np.array(p_values)
        auc_values = np.array(auc_values)
        significant = p_values < 0.05
        if np.sum(significant) > 0:
            index = np.argmax(significant * auc_values)
        else:
            index = np.argmin(p_values)
        return_stats[modality + " p-value"] = p_values[index]
        return_stats[modality + " AUC"] = auc_values[index]

    return return_stats


def main():
    """Generate and save unit summary plots."""
    # Load behavior data
    triangle_behavior = pd.read_csv(_BEHAVIOR_CACHE_PATH_TRIANGLE)
    ring_behavior = pd.read_csv(_BEHAVIOR_CACHE_PATH_RING)

    # Make unit dataframe
    for subject_dir in sorted(_FIRING_RATES_DATA_DIR.iterdir()):
        subject = subject_dir.name
        if subject.startswith("."):
            continue
        print(f"\nProcessing {subject}\n")
        for session_dir in sorted(subject_dir.iterdir()):
            session = session_dir.name
            if session.startswith("."):
                continue
            print(f"\nProcessing {session}\n")
            write_path = _WRITE_DIR / subject / session / "units.csv"
            if write_path.exists():
                continue

            # Load behavior data for this session
            session_behavior_triangle = triangle_behavior[
                (triangle_behavior["subject"] == subject)
                & (triangle_behavior["session"] == session)
            ]
            session_behavior_ring = ring_behavior[
                (ring_behavior["subject"] == subject)
                & (ring_behavior["session"] == session)
            ]
            if len(session_behavior_triangle) > 0:
                print(f"Triangle data found")
                session_behavior = session_behavior_triangle
            elif len(session_behavior_ring) > 0:
                print(f"Ring data found")
                session_behavior = session_behavior_ring
            else:
                raise ValueError("No behavior data found")

            # Load firing rates for this session
            df_firing_rates = pd.read_csv(session_dir / "fr.csv", index_col=0)

            # Create unit dataframe
            unit_df = {
                "task": [],
                "subject": [],
                "session": [],
                "probe": [],
                "quality": [],
                "unit": [],
                "mean_firing_rate": [],
                "Position p-value": [],
                "Position AUC": [],
                "Identity p-value": [],
                "Identity AUC": [],
            }
            unique_units = df_firing_rates["unit"].unique()
            for unit_index, unit in enumerate(unique_units):
                if unit_index % 20 == 0:
                    print(
                        f"Processing unit {unit_index} / {len(unique_units)}"
                    )
                df_unit_firing_rates = df_firing_rates[
                    df_firing_rates["unit"] == unit
                ]

                # Compute selectivities for position and identity
                stats = _get_selectivity(
                    df_unit_firing_rates, session_behavior
                )

                # Append to dataframe
                unit_df["task"].append(df_unit_firing_rates.task.values[0])
                unit_df["subject"].append(subject)
                unit_df["session"].append(session)
                unit_df["probe"].append(df_unit_firing_rates.probe.values[0])
                unit_df["quality"].append(
                    df_unit_firing_rates.quality.values[0]
                )
                unit_df["mean_firing_rate"].append(
                    df_unit_firing_rates.firing_rate.mean()
                )
                unit_df["unit"].append(unit)
                for key, value in stats.items():
                    unit_df[key].append(value)

            # Convert to pandas dataframe
            unit_df = pd.DataFrame(unit_df)

            # Add "significant" column indicating whether to use the unit for
            # modeling
            significant_pos = (unit_df["Position p-value"] < _MAX_P_VALUE) & (
                unit_df["Position AUC"] > _MIN_AUC
            )
            significant_id = (unit_df["Identity p-value"] < _MAX_P_VALUE) & (
                unit_df["Identity AUC"] > _MIN_AUC
            )
            sufficient_firing_rate = (
                unit_df["mean_firing_rate"] > _MIN_FIRING_RATE
            )
            unit_df["significant"] = sufficient_firing_rate & (
                significant_pos | significant_id
            )

            # Write dataframes
            write_path.parent.mkdir(parents=True, exist_ok=True)
            unit_df.to_csv(write_path, index=False)


if __name__ == "__main__":
    main()
